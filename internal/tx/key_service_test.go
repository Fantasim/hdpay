package tx

import (
	"context"
	"os"
	"path/filepath"
	"testing"

	"github.com/btcsuite/btcd/btcutil"
	"github.com/btcsuite/btcd/chaincfg"

	"github.com/Fantasim/hdpay/internal/wallet"
)

// Standard BIP-39 test mnemonic (12-word â€” known BIP-84 test vector).
const testMnemonic12 = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"

// Standard BIP-39 test mnemonic (24-word â€” primary test vector).
const testMnemonic24 = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art"

// writeTempMnemonic writes a mnemonic to a temp file and returns the path.
func writeTempMnemonic(t *testing.T, mnemonic string) string {
	t.Helper()
	dir := t.TempDir()
	path := filepath.Join(dir, "mnemonic.txt")
	if err := os.WriteFile(path, []byte(mnemonic), 0o600); err != nil {
		t.Fatalf("write temp mnemonic: %v", err)
	}
	return path
}

func TestKeyService_DeriveBTCPrivateKey_KnownVector(t *testing.T) {
	// Using the 24-word test mnemonic, derive key at index 0 and verify
	// the resulting public key produces the same address as wallet.DeriveBTCAddress.
	path := writeTempMnemonic(t, testMnemonic24)
	ks := NewKeyService(path, "mainnet")

	net := &chaincfg.MainNetParams

	privKey, err := ks.DeriveBTCPrivateKey(context.Background(), 0)
	if err != nil {
		t.Fatalf("DeriveBTCPrivateKey() error = %v", err)
	}
	defer privKey.Zero()

	// Derive the public key and address from the private key.
	pubKey := privKey.PubKey()
	witnessProg := btcutil.Hash160(pubKey.SerializeCompressed())
	addr, err := btcutil.NewAddressWitnessPubKeyHash(witnessProg, net)
	if err != nil {
		t.Fatalf("create address from derived key: %v", err)
	}

	// Get expected address from public derivation path.
	seed, err := wallet.MnemonicToSeed(testMnemonic24)
	if err != nil {
		t.Fatal(err)
	}
	masterKey, err := wallet.DeriveMasterKey(seed, net)
	if err != nil {
		t.Fatal(err)
	}
	want, err := wallet.DeriveBTCAddress(masterKey, 0, net)
	if err != nil {
		t.Fatal(err)
	}

	if addr.EncodeAddress() != want {
		t.Errorf("derived address = %v, want %v", addr.EncodeAddress(), want)
	}
}

func TestKeyService_DeriveBTCPrivateKey_MatchesPublicDerivation(t *testing.T) {
	// Verify that the private key derivation produces a key whose public key
	// matches the address generated by wallet.DeriveBTCAddress.
	path := writeTempMnemonic(t, testMnemonic24)
	ks := NewKeyService(path, "mainnet")

	net := &chaincfg.MainNetParams
	seed, err := wallet.MnemonicToSeed(testMnemonic24)
	if err != nil {
		t.Fatal(err)
	}
	masterKey, err := wallet.DeriveMasterKey(seed, net)
	if err != nil {
		t.Fatal(err)
	}

	for _, idx := range []uint32{0, 1, 5, 42} {
		t.Run("index_"+itoa(int(idx)), func(t *testing.T) {
			privKey, err := ks.DeriveBTCPrivateKey(context.Background(), idx)
			if err != nil {
				t.Fatalf("DeriveBTCPrivateKey(%d) error = %v", idx, err)
			}
			defer privKey.Zero()

			// Derive address from private key.
			pubKey := privKey.PubKey()
			witnessProg := btcutil.Hash160(pubKey.SerializeCompressed())
			addr, err := btcutil.NewAddressWitnessPubKeyHash(witnessProg, net)
			if err != nil {
				t.Fatal(err)
			}

			// Derive address via public path.
			expectedAddr, err := wallet.DeriveBTCAddress(masterKey, idx, net)
			if err != nil {
				t.Fatal(err)
			}

			if addr.EncodeAddress() != expectedAddr {
				t.Errorf("key-derived address %v != public-derived address %v at index %d",
					addr.EncodeAddress(), expectedAddr, idx)
			}
		})
	}
}

func TestKeyService_DeriveBTCPrivateKey_InvalidPath(t *testing.T) {
	ks := NewKeyService("/nonexistent/mnemonic.txt", "mainnet")

	_, err := ks.DeriveBTCPrivateKey(context.Background(), 0)
	if err == nil {
		t.Fatal("expected error for invalid mnemonic file path")
	}
}

func TestKeyService_DeriveBTCPrivateKey_EmptyMnemonicFile(t *testing.T) {
	path := writeTempMnemonic(t, "")
	ks := NewKeyService(path, "mainnet")

	_, err := ks.DeriveBTCPrivateKey(context.Background(), 0)
	if err == nil {
		t.Fatal("expected error for empty mnemonic file")
	}
}

func TestKeyService_MnemonicFileNotSet(t *testing.T) {
	ks := NewKeyService("", "mainnet")

	_, err := ks.DeriveBTCPrivateKey(context.Background(), 0)
	if err == nil {
		t.Fatal("expected error when mnemonic file not set")
	}
}

func TestKeyService_ContextCancellation(t *testing.T) {
	path := writeTempMnemonic(t, testMnemonic24)
	ks := NewKeyService(path, "mainnet")

	ctx, cancel := context.WithCancel(context.Background())
	cancel() // Cancel immediately.

	_, err := ks.DeriveBTCPrivateKey(ctx, 0)
	if err == nil {
		t.Fatal("expected error when context is cancelled")
	}
}

func TestKeyService_DeriveBSCPrivateKey_KnownVector(t *testing.T) {
	// Using the 24-word "abandon...art" mnemonic, index 0 should produce
	// the known BSC address: 0xF278cF59F82eDcf871d630F28EcC8056f25C1cdb
	path := writeTempMnemonic(t, testMnemonic24)
	ks := NewKeyService(path, "mainnet")

	privKey, addr, err := ks.DeriveBSCPrivateKey(context.Background(), 0)
	if err != nil {
		t.Fatalf("DeriveBSCPrivateKey(0) error = %v", err)
	}
	_ = privKey // We don't need to do anything with the key, just verify the address.

	expectedAddr := "0xF278cF59F82eDcf871d630F28EcC8056f25C1cdb"
	if addr.Hex() != expectedAddr {
		t.Errorf("BSC address index 0: got %s, want %s", addr.Hex(), expectedAddr)
	}
}

func TestKeyService_DeriveBSCPrivateKey_MultipleIndices(t *testing.T) {
	// Derive keys at indices 0, 1, 2 and verify they produce distinct addresses
	// matching the known test vectors from MEMORY.md.
	path := writeTempMnemonic(t, testMnemonic24)
	ks := NewKeyService(path, "mainnet")

	expectedAddrs := []string{
		"0xF278cF59F82eDcf871d630F28EcC8056f25C1cdb",
		"0xf785bD075874b8423D3583728a981399f31e95aA",
		"0x60Af1c6A5D03F9f1B1b74931499bC99E72fF8DA9",
	}

	seen := make(map[string]bool)
	for i, expected := range expectedAddrs {
		privKey, addr, err := ks.DeriveBSCPrivateKey(context.Background(), uint32(i))
		if err != nil {
			t.Fatalf("DeriveBSCPrivateKey(%d) error = %v", i, err)
		}
		_ = privKey

		if addr.Hex() != expected {
			t.Errorf("BSC address index %d: got %s, want %s", i, addr.Hex(), expected)
		}

		if seen[addr.Hex()] {
			t.Errorf("duplicate address at index %d: %s", i, addr.Hex())
		}
		seen[addr.Hex()] = true
	}
}

func TestKeyService_DeriveBSCPrivateKey_MnemonicFileNotSet(t *testing.T) {
	ks := NewKeyService("", "mainnet")

	_, _, err := ks.DeriveBSCPrivateKey(context.Background(), 0)
	if err == nil {
		t.Fatal("expected error when mnemonic file not set")
	}
}

func TestKeyService_DeriveBSCPrivateKey_ContextCancelled(t *testing.T) {
	path := writeTempMnemonic(t, testMnemonic24)
	ks := NewKeyService(path, "mainnet")

	ctx, cancel := context.WithCancel(context.Background())
	cancel()

	_, _, err := ks.DeriveBSCPrivateKey(ctx, 0)
	if err == nil {
		t.Fatal("expected error when context is cancelled")
	}
}

// itoa is a simple int to string converter for test names.
func itoa(n int) string {
	if n == 0 {
		return "0"
	}
	s := ""
	for n > 0 {
		s = string(rune('0'+n%10)) + s
		n /= 10
	}
	return s
}
