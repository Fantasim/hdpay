package tx

import (
	"context"
	"os"
	"path/filepath"
	"testing"

	"github.com/btcsuite/btcd/btcutil"
	"github.com/btcsuite/btcd/chaincfg"

	"github.com/Fantasim/hdpay/internal/wallet"
)

// Standard BIP-39 test mnemonic (12-word â€” known BIP-84 test vector).
const testMnemonic12 = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"

// Standard BIP-39 test mnemonic (24-word â€” primary test vector).
const testMnemonic24 = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art"

// writeTempMnemonic writes a mnemonic to a temp file and returns the path.
func writeTempMnemonic(t *testing.T, mnemonic string) string {
	t.Helper()
	dir := t.TempDir()
	path := filepath.Join(dir, "mnemonic.txt")
	if err := os.WriteFile(path, []byte(mnemonic), 0o600); err != nil {
		t.Fatalf("write temp mnemonic: %v", err)
	}
	return path
}

func TestKeyService_DeriveBTCPrivateKey_KnownVector(t *testing.T) {
	// Using the 24-word test mnemonic, derive key at index 0 and verify
	// the resulting public key produces the same address as wallet.DeriveBTCAddress.
	path := writeTempMnemonic(t, testMnemonic24)
	ks := NewKeyService(path, "mainnet")

	net := &chaincfg.MainNetParams

	privKey, err := ks.DeriveBTCPrivateKey(context.Background(), 0)
	if err != nil {
		t.Fatalf("DeriveBTCPrivateKey() error = %v", err)
	}
	defer privKey.Zero()

	// Derive the public key and address from the private key.
	pubKey := privKey.PubKey()
	witnessProg := btcutil.Hash160(pubKey.SerializeCompressed())
	addr, err := btcutil.NewAddressWitnessPubKeyHash(witnessProg, net)
	if err != nil {
		t.Fatalf("create address from derived key: %v", err)
	}

	// Get expected address from public derivation path.
	seed, err := wallet.MnemonicToSeed(testMnemonic24)
	if err != nil {
		t.Fatal(err)
	}
	masterKey, err := wallet.DeriveMasterKey(seed, net)
	if err != nil {
		t.Fatal(err)
	}
	want, err := wallet.DeriveBTCAddress(masterKey, 0, net)
	if err != nil {
		t.Fatal(err)
	}

	if addr.EncodeAddress() != want {
		t.Errorf("derived address = %v, want %v", addr.EncodeAddress(), want)
	}
}

func TestKeyService_DeriveBTCPrivateKey_MatchesPublicDerivation(t *testing.T) {
	// Verify that the private key derivation produces a key whose public key
	// matches the address generated by wallet.DeriveBTCAddress.
	path := writeTempMnemonic(t, testMnemonic24)
	ks := NewKeyService(path, "mainnet")

	net := &chaincfg.MainNetParams
	seed, err := wallet.MnemonicToSeed(testMnemonic24)
	if err != nil {
		t.Fatal(err)
	}
	masterKey, err := wallet.DeriveMasterKey(seed, net)
	if err != nil {
		t.Fatal(err)
	}

	for _, idx := range []uint32{0, 1, 5, 42} {
		t.Run("index_"+itoa(int(idx)), func(t *testing.T) {
			privKey, err := ks.DeriveBTCPrivateKey(context.Background(), idx)
			if err != nil {
				t.Fatalf("DeriveBTCPrivateKey(%d) error = %v", idx, err)
			}
			defer privKey.Zero()

			// Derive address from private key.
			pubKey := privKey.PubKey()
			witnessProg := btcutil.Hash160(pubKey.SerializeCompressed())
			addr, err := btcutil.NewAddressWitnessPubKeyHash(witnessProg, net)
			if err != nil {
				t.Fatal(err)
			}

			// Derive address via public path.
			expectedAddr, err := wallet.DeriveBTCAddress(masterKey, idx, net)
			if err != nil {
				t.Fatal(err)
			}

			if addr.EncodeAddress() != expectedAddr {
				t.Errorf("key-derived address %v != public-derived address %v at index %d",
					addr.EncodeAddress(), expectedAddr, idx)
			}
		})
	}
}

func TestKeyService_DeriveBTCPrivateKey_InvalidPath(t *testing.T) {
	ks := NewKeyService("/nonexistent/mnemonic.txt", "mainnet")

	_, err := ks.DeriveBTCPrivateKey(context.Background(), 0)
	if err == nil {
		t.Fatal("expected error for invalid mnemonic file path")
	}
}

func TestKeyService_DeriveBTCPrivateKey_EmptyMnemonicFile(t *testing.T) {
	path := writeTempMnemonic(t, "")
	ks := NewKeyService(path, "mainnet")

	_, err := ks.DeriveBTCPrivateKey(context.Background(), 0)
	if err == nil {
		t.Fatal("expected error for empty mnemonic file")
	}
}

func TestKeyService_MnemonicFileNotSet(t *testing.T) {
	ks := NewKeyService("", "mainnet")

	_, err := ks.DeriveBTCPrivateKey(context.Background(), 0)
	if err == nil {
		t.Fatal("expected error when mnemonic file not set")
	}
}

func TestKeyService_ContextCancellation(t *testing.T) {
	path := writeTempMnemonic(t, testMnemonic24)
	ks := NewKeyService(path, "mainnet")

	ctx, cancel := context.WithCancel(context.Background())
	cancel() // Cancel immediately.

	_, err := ks.DeriveBTCPrivateKey(ctx, 0)
	if err == nil {
		t.Fatal("expected error when context is cancelled")
	}
}

// itoa is a simple int to string converter for test names.
func itoa(n int) string {
	if n == 0 {
		return "0"
	}
	s := ""
	for n > 0 {
		s = string(rune('0'+n%10)) + s
		n /= 10
	}
	return s
}
